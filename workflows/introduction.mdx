---
title: Workflows æ˜¯ä»€ä¹ˆï¼Ÿ
sidebarTitle: æ¦‚è¿°
---

Workflows æ˜¯ä¸ºç”Ÿäº§åº”ç”¨ç¨‹åºæ„å»ºçš„ç¡®å®šæ€§ã€æœ‰çŠ¶æ€ã€å¤šä»£ç†ç¨‹åºã€‚å®ƒä»¬ç»è¿‡å®æˆ˜æ£€éªŒï¼ŒåŠŸèƒ½å¼ºå¤§ï¼Œå¹¶æä¾›ä»¥ä¸‹ä¼˜åŠ¿ï¼š

- **çº¯ Python**: ä½¿ç”¨æ ‡å‡†çš„ Python æ„å»ºæ‚¨çš„å·¥ä½œæµç¨‹é€»è¾‘ã€‚åœ¨æ„å»ºäº†æ•°ç™¾ä¸ªä»£ç†ç³»ç»Ÿåï¼Œ**æ²¡æœ‰ä»»ä½•æ¡†æ¶æˆ–åŸºäºæ­¥éª¤çš„æ–¹æ³•èƒ½æä¾›çº¯ Python æ‰€å…·æœ‰çš„çµæ´»æ€§å’Œå¯é æ€§**ã€‚æƒ³è¦å¾ªç¯ï¼Ÿä½¿ç”¨ `while`/`for`ï¼›æƒ³è¦æ¡ä»¶ï¼Ÿä½¿ç”¨ `if`/`else`ï¼›æƒ³è¦å¼‚å¸¸å¤„ç†ï¼Ÿä½¿ç”¨ `try`/`except`ã€‚
- **å®Œå…¨æ§åˆ¶å’Œçµæ´»æ€§**: å› ä¸ºæ‚¨çš„å·¥ä½œæµç¨‹é€»è¾‘æ˜¯ä¸€ä¸ª Python å‡½æ•°ï¼Œæ‰€ä»¥æ‚¨å¯ä»¥å®Œå…¨æ§åˆ¶æ•´ä¸ªè¿‡ç¨‹ï¼Œä¾‹å¦‚åœ¨å¤„ç†ä¹‹å‰éªŒè¯è¾“å…¥ï¼Œç”Ÿæˆä»£ç†å¹¶å¹¶è¡Œè¿è¡Œå®ƒä»¬ï¼Œæ ¹æ®éœ€è¦ç¼“å­˜ç»“æœä»¥åŠçº æ­£ä»»ä½•ä¸­é—´é”™è¯¯ã€‚**è¿™ç§çº§åˆ«çš„æ§åˆ¶å¯¹äºå¯é æ€§è‡³å…³é‡è¦ã€‚**
- **å†…ç½®å­˜å‚¨å’Œç¼“å­˜**: Workflows é™„å¸¦å†…ç½®çš„å­˜å‚¨å’ŒçŠ¶æ€ç®¡ç†ã€‚ä½¿ç”¨ `session_state` æ¥ç¼“å­˜ä¸­é—´ç»“æœã€‚è¿™ç§æ–¹æ³•çš„ä¸€å¤§ä¼˜åŠ¿æ˜¯ï¼Œæ‚¨å¯ä»¥åœ¨å•ç‹¬çš„è¿›ç¨‹ä¸­è§¦å‘å·¥ä½œæµç¨‹ï¼Œç¨åè¿›è¡Œè½®è¯¢ä»¥è·å–ç»“æœï¼Œè¿™æ„å‘³ç€æ‚¨ä¸ä¼šé‡åˆ°é•¿æ—¶é—´è¿è¡Œçš„å·¥ä½œæµç¨‹ä¸­éå¸¸å¸¸è§çš„è¯·æ±‚è¶…æ—¶é—®é¢˜ã€‚

<Check>

å› ä¸ºå·¥ä½œæµç¨‹é€»è¾‘æ˜¯ä¸€ä¸ª Python å‡½æ•°ï¼Œæ‰€ä»¥ AI ä»£ç ç¼–è¾‘å™¨å¯ä»¥ä¸ºæ‚¨ç¼–å†™å·¥ä½œæµç¨‹ã€‚åªéœ€å°† `https://docs.agno.com` æ·»åŠ ä¸ºæ–‡æ¡£æºå³å¯ã€‚

</Check>

### æœ€æ£’çš„éƒ¨åˆ†

æ— éœ€å­¦ä¹ æ–°ä¸œè¥¿ï¼æ‚¨å·²ç»æŒæ¡äº† Pythonï¼Œå·²ç»æŒæ¡äº†å¦‚ä½•æ„å»º Agents å’Œ Teamsâ€”â€”ç°åœ¨åªéœ€ä½¿ç”¨å¸¸è§„çš„ Python ä»£ç å°†å®ƒä»¬ç»„åˆèµ·æ¥å³å¯ã€‚æ— éœ€å­¦ä¹ æ–°çš„ DSL æˆ–è¯­æ³•ã€‚

è¿™æ˜¯ä¸€ä¸ªç¼“å­˜è¾“å‡ºçš„ç®€å•å·¥ä½œæµç¨‹ã€‚æ‚¨å¯ä»¥çœ‹åˆ°å³ä½¿æ˜¯â€œå­˜å‚¨çŠ¶æ€â€å‘ç”Ÿåœ¨å“åº”åäº§ç”Ÿï¼Œæ‚¨å¯¹æ•´ä¸ªè¿‡ç¨‹çš„æ§åˆ¶ç¨‹åº¦ã€‚

```python simple_cache_workflow.py
from typing import Iterator

from agno.agent import Agent, RunResponse
from agno.models.openai import OpenAIChat
from agno.utils.log import logger
from agno.utils.pprint import pprint_run_response
from agno.workflow import Workflow


class CacheWorkflow(Workflow):
    # çº¯ç²¹æè¿°æ€§çš„ï¼Œå·¥ä½œæµç¨‹ä¸ä½¿ç”¨
    description: str = "A workflow that caches previous outputs"

    # å°†ä»£ç†æˆ–å›¢é˜Ÿæ·»åŠ ä¸ºå·¥ä½œæµç¨‹çš„å±æ€§
    agent = Agent(model=OpenAIChat(id="gpt-4o-mini"))

    # åœ¨ `run()` æ–¹æ³•ä¸­ç¼–å†™é€»è¾‘
    def run(self, message: str) -> Iterator[RunResponse]:
        logger.info(f"Checking cache for '{message}'")
        # æ£€æŸ¥è¾“å‡ºæ˜¯å¦å·²ç¼“å­˜
        if self.session_state.get(message):
            logger.info(f"Cache hit for '{message}'")
            yield RunResponse(run_id=self.run_id, content=self.session_state.get(message))
            return

        logger.info(f"Cache miss for '{message}'")
        # è¿è¡Œä»£ç†å¹¶äº§ç”Ÿå“åº”
        yield from self.agent.run(message, stream=True)

        # è¯·æ±‚äº§ç”Ÿåç¼“å­˜è¾“å‡º
        self.session_state[message] = self.agent.run_response.content


if __name__ == "__main__":
    workflow = CacheWorkflow()
    # è¿è¡Œå·¥ä½œæµç¨‹ï¼ˆæ­¤æ“ä½œéœ€è¦å¤§çº¦ 1 ç§’ï¼‰
    response: Iterator[RunResponse] = workflow.run(message="Tell me a joke.")
    # æ‰“å°å“åº”
    pprint_run_response(response, markdown=True, show_time=True)
    # å†æ¬¡è¿è¡Œå·¥ä½œæµç¨‹ï¼ˆç”±äºç¼“å­˜ï¼Œæ­¤æ“ä½œç«‹å³å®Œæˆï¼‰
    response: Iterator[RunResponse] = workflow.run(message="Tell me a joke.")
    # æ‰“å°å“åº”
    pprint_run_response(response, markdown=True, show_time=True)
```

### å¦‚ä½•æ„å»ºå·¥ä½œæµç¨‹

1. é€šè¿‡ç»§æ‰¿ `Workflow` ç±»æ¥å®šä¹‰æ‚¨çš„å·¥ä½œæµç¨‹ç±»ã€‚
2. å°†ä»£ç†æˆ–å›¢é˜Ÿæ·»åŠ ä¸ºå·¥ä½œæµç¨‹çš„å±æ€§ã€‚è¿™ä¸æ˜¯ä¸¥æ ¼è¦æ±‚ï¼Œåªæ˜¯å¸®åŠ©æˆ‘ä»¬å°†ä»£ç†çš„ä¼šè¯ ID æ˜ å°„åˆ°å·¥ä½œæµç¨‹çš„ä¼šè¯ IDã€‚
3. åœ¨ `run()` æ–¹æ³•ä¸­å®ç°å·¥ä½œæµç¨‹é€»è¾‘ã€‚è¿™æ˜¯è¿è¡Œå·¥ä½œæµç¨‹æ—¶å°†è°ƒç”¨çš„ä¸»å‡½æ•°ï¼ˆ**å·¥ä½œæµç¨‹å…¥å£ç‚¹**ï¼‰ã€‚æ­¤å‡½æ•°ä½¿æˆ‘ä»¬èƒ½å¤Ÿå……åˆ†æ§åˆ¶æ•´ä¸ªè¿‡ç¨‹ï¼ŒæŸäº›ä»£ç†å¯ä»¥æµå¼ä¼ è¾“ï¼Œå…¶ä»–ä»£ç†å¯ä»¥ç”Ÿæˆç»“æ„åŒ–è¾“å‡ºï¼Œä»£ç†å¯ä»¥ä½¿ç”¨ `async.gather()` å¹¶è¡Œè¿è¡Œï¼ŒæŸäº›ä»£ç†å¯ä»¥å…·æœ‰åœ¨è¿”å›å“åº”ä¹‹å‰è¿è¡Œçš„éªŒè¯é€»è¾‘ã€‚

<Note>
æ‚¨ä¹Ÿå¯ä»¥ä½¿ç”¨ `arun` æ–¹æ³•å¼‚æ­¥æ‰§è¡Œå·¥ä½œæµç¨‹ã€‚è¿™å…è®¸åœ¨è°ƒç”¨ä»£ç†æ—¶è¿›è¡Œæ›´é«˜æ•ˆçš„éé˜»å¡æ“ä½œã€‚æœ‰å…³è¯¦ç»†ç¤ºä¾‹ï¼Œè¯·å‚é˜… [Async Workflows ç¤ºä¾‹](examples/workflows/async-hackernews-reporter)ã€‚
</Note>

## å®Œæ•´ç¤ºä¾‹ï¼šåšå®¢æ–‡ç« ç”Ÿæˆå™¨

è®©æˆ‘ä»¬åˆ›å»ºä¸€ä¸ªåšå®¢æ–‡ç« ç”Ÿæˆå™¨ï¼Œå®ƒå¯ä»¥æœç´¢ç½‘ç»œã€é˜…è¯»çƒ­é—¨é“¾æ¥å¹¶ä¸ºæˆ‘ä»¬æ’°å†™åšå®¢æ–‡ç« ã€‚æˆ‘ä»¬å°†ç¼“å­˜æ•°æ®åº“ä¸­çš„ä¸­é—´ç»“æœä»¥æé«˜æ€§èƒ½ã€‚

### åˆ›å»ºå·¥ä½œæµç¨‹

1. é€šè¿‡ç»§æ‰¿ `Workflow` ç±»æ¥å®šä¹‰æ‚¨çš„å·¥ä½œæµç¨‹ç±»ã€‚

```python blog_post_generator.py
from agno.workflow import Workflow

class BlogPostGenerator(Workflow):
    pass
```

2. å‘å·¥ä½œæµç¨‹æ·»åŠ ä¸€ä¸ªæˆ–å¤šä¸ªä»£ç†ï¼Œå¹¶åœ¨ `run()` æ–¹æ³•ä¸­å®ç°å·¥ä½œæµç¨‹é€»è¾‘ã€‚

```python blog_post_generator.py
import json
from textwrap import dedent
from typing import Dict, Iterator, Optional

from agno.agent import Agent
from agno.models.openai import OpenAIChat
from agno.storage.sqlite import SqliteStorage
from agno.tools.duckduckgo import DuckDuckGoTools
from agno.tools.newspaper4k import Newspaper4kTools
from agno.utils.log import logger
from agno.utils.pprint import pprint_run_response
from agno.workflow import RunEvent, RunResponse, Workflow
from pydantic import BaseModel, Field


class NewsArticle(BaseModel):
    title: str = Field(..., description="Title of the article.")
    url: str = Field(..., description="Link to the article.")
    summary: Optional[str] = Field(
        ..., description="Summary of the article if available."
    )


class SearchResults(BaseModel):
    articles: list[NewsArticle]


class ScrapedArticle(BaseModel):
    title: str = Field(..., description="Title of the article.")
    url: str = Field(..., description="Link to the article.")
    summary: Optional[str] = Field(
        ..., description="Summary of the article if available."
    )
    content: Optional[str] = Field(
        ...,
        description="Full article content in markdown format. None if content is unavailable.",
    )


class BlogPostGenerator(Workflow):
    """Advanced workflow for generating professional blog posts with proper research and citations."""

    description: str = dedent("""\
    An intelligent blog post generator that creates engaging, well-researched content.
    This workflow orchestrates multiple AI agents to research, analyze, and craft
    compelling blog posts that combine journalistic rigor with engaging storytelling.
    The system excels at creating content that is both informative and optimized for
    digital consumption.
    """)

    # Search Agent: Handles intelligent web searching and source gathering
    searcher: Agent = Agent(
        model=OpenAIChat(id="gpt-4o-mini"),
        tools=[DuckDuckGoTools()],
        description=dedent("""\
        You are BlogResearch-X, an elite research assistant specializing in discovering
        high-quality sources for compelling blog content. Your expertise includes:

        - Finding authoritative and trending sources
        - Evaluating content credibility and relevance
        - Identifying diverse perspectives and expert opinions
        - Discovering unique angles and insights
        - Ensuring comprehensive topic coverage\
        """),
        instructions=dedent("""\
        1. Search Strategy ğŸ”
           - Find 10-15 relevant sources and select the 5-7 best ones
           - Prioritize recent, authoritative content
           - Look for unique angles and expert insights
        2. Source Evaluation ğŸ“Š
           - Verify source credibility and expertise
           - Check publication dates for timeliness
           - Assess content depth and uniqueness
        3. Diversity of Perspectives ğŸŒ
           - Include different viewpoints
           - Gather both mainstream and expert opinions
           - Find supporting data and statistics\
        """),
        response_model=SearchResults,
    )

    # Content Scraper: Extracts and processes article content
    article_scraper: Agent = Agent(
        model=OpenAIChat(id="gpt-4o-mini"),
        tools=[Newspaper4kTools()],
        description=dedent("""\
        You are ContentBot-X, a specialist in extracting and processing digital content
        for blog creation. Your expertise includes:

        - Efficient content extraction
        - Smart formatting and structuring
        - Key information identification
        - Quote and statistic preservation
        - Maintaining source attribution\
        """),
        instructions=dedent("""\
        1. Content Extraction ğŸ“‘
           - Extract content from the article
           - Preserve important quotes and statistics
           - Maintain proper attribution
           - Handle paywalls gracefully
        2. Content Processing ğŸ”„
           - Format text in clean markdown
           - Preserve key information
           - Structure content logically
        3. Quality Control âœ…
           - Verify content relevance
           - Ensure accurate extraction
           - Maintain readability\
        """),
        response_model=ScrapedArticle,
        structured_outputs=True,
    )

    # Content Writer Agent: Crafts engaging blog posts from research
    writer: Agent = Agent(
        model=OpenAIChat(id="gpt-4o"),
        description=dedent("""\
        You are BlogMaster-X, an elite content creator combining journalistic excellence
        with digital marketing expertise. Your strengths include:

        - Crafting viral-worthy headlines
        - Writing engaging introductions
        - Structuring content for digital consumption
        - Incorporating research seamlessly
        - Optimizing for SEO while maintaining quality
        - Creating shareable conclusions\
        """),
        instructions=dedent("""\
        1. Content Strategy ğŸ“
           - Craft attention-grabbing headlines
           - Write compelling introductions
           - Structure content for engagement
           - Include relevant subheadings
        2. Writing Excellence âœï¸
           - Balance expertise with accessibility
           - Use clear, engaging language
           - Include relevant examples
           - Incorporate statistics naturally
        3. Source Integration ğŸ”
           - Cite sources properly
           - Include expert quotes
           - Maintain factual accuracy
        4. Digital Optimization ğŸ’»
           - Structure for scanability
           - Include shareable takeaways
           - Optimize for SEO
           - Add engaging subheadings\
        """),
        expected_output=dedent("""\
        # {Viral-Worthy Headline}

        ## Introduction
        {Engaging hook and context}

        ## {Compelling Section 1}
        {Key insights and analysis}
        {Expert quotes and statistics}

        ## {Engaging Section 2}
        {Deeper exploration}
        {Real-world examples}

        ## {Practical Section 3}
        {Actionable insights}
        {Expert recommendations}

        ## Key Takeaways
        - {Shareable insight 1}
        - {Practical takeaway 2}
        - {Notable finding 3}

        ## Sources
        {Properly attributed sources with links}\
        """),
        markdown=True,
    )

    def run(
        self,
        topic: str,
        use_search_cache: bool = True,
        use_scrape_cache: bool = True,
        use_cached_report: bool = True,
    ) -> Iterator[RunResponse]:
        logger.info(f"Generating a blog post on: {topic}")

        # å¦‚æœ use_cache ä¸º Trueï¼Œåˆ™ä½¿ç”¨ç¼“å­˜çš„åšå®¢æ–‡ç« 
        if use_cached_report:
            cached_blog_post = self.get_cached_blog_post(topic)
            if cached_blog_post:
                yield RunResponse(
                    content=cached_blog_post, event=RunEvent.workflow_completed
                )
                return

        # æœç´¢æœ‰å…³è¯¥ä¸»é¢˜çš„æ–‡ç« 
        search_results: Optional[SearchResults] = self.get_search_results(
            topic, use_search_cache
        )
        # å¦‚æœæ‰¾ä¸åˆ°è¯¥ä¸»é¢˜çš„ search_resultsï¼Œåˆ™ç»“æŸå·¥ä½œæµç¨‹
        if search_results is None or len(search_results.articles) == 0:
            yield RunResponse(
                event=RunEvent.workflow_completed,
                content=f"Sorry, could not find any articles on the topic: {topic}",
            )
            return

        # æŠ“å–æœç´¢ç»“æœ
        scraped_articles: Dict[str, ScrapedArticle] = self.scrape_articles(
            topic, search_results, use_scrape_cache
        )

        # ä¸º writer å‡†å¤‡è¾“å…¥
        writer_input = {
            "topic": topic,
            "articles": [v.model_dump() for v in scraped_articles.values()],
        }

        # è¿è¡Œ writer å¹¶äº§ç”Ÿå“åº”
        yield from self.writer.run(json.dumps(writer_input, indent=4), stream=True)

        # å°†åšå®¢æ–‡ç« ä¿å­˜åœ¨ç¼“å­˜ä¸­
        self.add_blog_post_to_cache(topic, self.writer.run_response.content)

    def get_cached_blog_post(self, topic: str) -> Optional[str]:
        logger.info("Checking if cached blog post exists")

        return self.session_state.get("blog_posts", {}).get(topic)

    def add_blog_post_to_cache(self, topic: str, blog_post: str):
        logger.info(f"Saving blog post for topic: {topic}")
        self.session_state.setdefault("blog_posts", {})
        self.session_state["blog_posts"][topic] = blog_post

    def get_cached_search_results(self, topic: str) -> Optional[SearchResults]:
        logger.info("Checking if cached search results exist")
        search_results = self.session_state.get("search_results", {}).get(topic)
        return (
            SearchResults.model_validate(search_results)
            if search_results and isinstance(search_results, dict)
            else search_results
        )

    def add_search_results_to_cache(self, topic: str, search_results: SearchResults):
        logger.info(f"Saving search results for topic: {topic}")
        self.session_state.setdefault("search_results", {})
        self.session_state["search_results"][topic] = search_results

    def get_cached_scraped_articles(
        self, topic: str
    ) -> Optional[Dict[str, ScrapedArticle]]:
        logger.info("Checking if cached scraped articles exist")
        scraped_articles = self.session_state.get("scraped_articles", {}).get(topic)
        return (
            ScrapedArticle.model_validate(scraped_articles)
            if scraped_articles and isinstance(scraped_articles, dict)
            else scraped_articles
        )

    def add_scraped_articles_to_cache(
        self, topic: str, scraped_articles: Dict[str, ScrapedArticle]
    ):
        logger.info(f"Saving scraped articles for topic: {topic}")
        self.session_state.setdefault("scraped_articles", {})
        self.session_state["scraped_articles"][topic] = scraped_articles

    def get_search_results(
        self, topic: str, use_search_cache: bool, num_attempts: int = 3
    ) -> Optional[SearchResults]:
        # å¦‚æœ use_search_cache ä¸º Trueï¼Œåˆ™ä»ä¼šè¯çŠ¶æ€è·å–ç¼“å­˜çš„ search_results
        if use_search_cache:
            try:
                search_results_from_cache = self.get_cached_search_results(topic)
                if search_results_from_cache is not None:
                    search_results = SearchResults.model_validate(
                        search_results_from_cache
                    )
                    logger.info(
                        f"Found {len(search_results.articles)} articles in cache."
                    )
                    return search_results
            except Exception as e:
                logger.warning(f"Could not read search results from cache: {e}")

        # å¦‚æœæ²¡æœ‰ç¼“å­˜çš„ search_resultsï¼Œåˆ™ä½¿ç”¨ searcher æŸ¥æ‰¾æœ€æ–°æ–‡ç« 
        for attempt in range(num_attempts):
            try:
                searcher_response: RunResponse = self.searcher.run(topic)
                if (
                    searcher_response is not None
                    and searcher_response.content is not None
                    and isinstance(searcher_response.content, SearchResults)
                ):
                    article_count = len(searcher_response.content.articles)
                    logger.info(
                        f"Found {article_count} articles on attempt {attempt + 1}"
                    )
                    # ç¼“å­˜æœç´¢ç»“æœ
                    self.add_search_results_to_cache(topic, searcher_response.content)
                    return searcher_response.content
                else:
                    logger.warning(
                        f"Attempt {attempt + 1}/{num_attempts} failed: Invalid response type"
                    )
            except Exception as e:
                logger.warning(f"Attempt {attempt + 1}/{num_attempts} failed: {str(e)}")

        logger.error(f"Failed to get search results after {num_attempts} attempts")
        return None

    def scrape_articles(
        self, topic: str, search_results: SearchResults, use_scrape_cache: bool
    ) -> Dict[str, ScrapedArticle]:
        scraped_articles: Dict[str, ScrapedArticle] = {}

        # å¦‚æœ use_scrape_cache ä¸º Trueï¼Œåˆ™ä»ä¼šè¯çŠ¶æ€è·å–ç¼“å­˜çš„ scraped_articles
        if use_scrape_cache:
            try:
                scraped_articles_from_cache = self.get_cached_scraped_articles(topic)
                if scraped_articles_from_cache is not None:
                    scraped_articles = scraped_articles_from_cache
                    logger.info(
                        f"Found {len(scraped_articles)} scraped articles in cache."
                    )
                    return scraped_articles
            except Exception as e:
                logger.warning(f"Could not read scraped articles from cache: {e}")

        # æŠ“å–ä¸åœ¨ç¼“å­˜ä¸­çš„æ–‡ç« 
        for article in search_results.articles:
            if article.url in scraped_articles:
                logger.info(f"Found scraped article in cache: {article.url}")
                continue

            article_scraper_response: RunResponse = self.article_scraper.run(
                article.url
            )
            if (
                article_scraper_response is not None
                and article_scraper_response.content is not None
                and isinstance(article_scraper_response.content, ScrapedArticle)
            ):
                scraped_articles[article_scraper_response.content.url] = (
                    article_scraper_response.content
                )
                logger.info(f"Scraped article: {article_scraper_response.content.url}")

        # å°†æŠ“å–çš„æ–‡ç« ä¿å­˜åœ¨ä¼šè¯çŠ¶æ€ä¸­
        self.add_scraped_articles_to_cache(topic, scraped_articles)
        return scraped_articles


# å¦‚æœè„šæœ¬ç›´æ¥æ‰§è¡Œï¼Œåˆ™è¿è¡Œå·¥ä½œæµç¨‹
if __name__ == "__main__":
    import random

    from rich.prompt import Prompt

    # å±•ç¤ºç”Ÿæˆå™¨å¤šåŠŸèƒ½æ€§çš„æœ‰è¶£ç¤ºä¾‹æç¤º
    example_prompts = [
        "Why Cats Secretly Run the Internet",
        "The Science Behind Why Pizza Tastes Better at 2 AM",
        "Time Travelers' Guide to Modern Social Media",
        "How Rubber Ducks Revolutionized Software Development",
        "The Secret Society of Office Plants: A Survival Guide",
        "Why Dogs Think We're Bad at Smelling Things",
        "The Underground Economy of Coffee Shop WiFi Passwords",
        "A Historical Analysis of Dad Jokes Through the Ages",
    ]

    # ä»ç”¨æˆ·å¤„è·å–ä¸»é¢˜
    topic = Prompt.ask(
        "[bold]Enter a blog post topic[/bold] (or press Enter for a random example)\nâœ¨",
        default=random.choice(example_prompts),
    )

    # å°†ä¸»é¢˜è½¬æ¢ä¸º URL å®‰å…¨å­—ç¬¦ä¸²ä»¥ç”¨ä½œ session_id
    url_safe_topic = topic.lower().replace(" ", "-")

    # åˆå§‹åŒ–åšå®¢æ–‡ç« ç”Ÿæˆå™¨å·¥ä½œæµç¨‹
    # - åŸºäºä¸»é¢˜åˆ›å»ºå”¯ä¸€çš„ä¼šè¯ ID
    # - è®¾ç½® SQLite å­˜å‚¨ä»¥ç¼“å­˜ç»“æœ
    generate_blog_post = BlogPostGenerator(
        session_id=f"generate-blog-post-on-{url_safe_topic}",
        storage=SqliteStorage(
            table_name="generate_blog_post_workflows",
            db_file="tmp/agno_workflows.db",
        ),
        debug_mode=True,
    )

    # ä½¿ç”¨ç¼“å­˜æ‰§è¡Œå·¥ä½œæµç¨‹
    # è¿”å›ä¸€ä¸ª RunResponse å¯¹è±¡è¿­ä»£å™¨ï¼Œå…¶ä¸­åŒ…å«ç”Ÿæˆçš„åšå®¢æ–‡ç« å†…å®¹
    blog_post: Iterator[RunResponse] = generate_blog_post.run(
        topic=topic,
        use_search_cache=True,
        use_scrape_cache=True,
        use_cached_report=True,
    )

    # æ‰“å°å“åº”
    pprint_run_response(blog_post, markdown=True)
```

### è¿è¡Œå·¥ä½œæµç¨‹

å®‰è£…åº“

```shell
pip install agno openai duckduckgo-search sqlalchemy
```

è¿è¡Œå·¥ä½œæµç¨‹

```shell
python blog_post_generator.py
```

ç°åœ¨ï¼Œç»“æœå·²ç¼“å­˜åˆ°æ•°æ®åº“ä¸­ï¼Œå¯ä¾›å°†æ¥è¿è¡Œé‡å¤ä½¿ç”¨ã€‚å†æ¬¡è¿è¡Œå·¥ä½œæµç¨‹ä»¥æŸ¥çœ‹ç¼“å­˜çš„ç»“æœã€‚

```shell
python blog_post_generator.py
```

<img
  height="200"
  src="/images/BlogPostGenerator.gif"
  style={{ borderRadius: '8px' }}
/>

æŸ¥çœ‹æ›´å¤šä¸å·¥ä½œæµç¨‹ç›¸å…³çš„[ç”¨ä¾‹](/examples/workflows/)å’Œ[ç¤ºä¾‹](/examples/concepts/storage/workflow_storage)ã€‚


## è®¾è®¡å†³ç­–

<Tip>

**ä¸ºä»€ä¹ˆæˆ‘ä»¬å»ºè®®å°†å·¥ä½œæµç¨‹é€»è¾‘å†™æˆ Python å‡½æ•°ï¼Œè€Œä¸æ˜¯åˆ›å»ºè‡ªå®šä¹‰æŠ½è±¡ï¼Œå¦‚ Graphã€Chain æˆ– Flowï¼Ÿ**

æ ¹æ®æˆ‘ä»¬æ„å»º AI äº§å“çš„ç»éªŒï¼Œå·¥ä½œæµç¨‹é€»è¾‘éœ€è¦æ˜¯åŠ¨æ€çš„ï¼ˆå³åœ¨è¿è¡Œæ—¶ç¡®å®šï¼‰ï¼Œå¹¶ä¸”éœ€è¦å¯¹å¹¶è¡ŒåŒ–ã€ç¼“å­˜ã€çŠ¶æ€ç®¡ç†ã€é”™è¯¯å¤„ç†å’Œé—®é¢˜è§£å†³è¿›è¡Œç»†ç²’åº¦æ§åˆ¶ã€‚

è‡ªå®šä¹‰æŠ½è±¡ï¼ˆGraphã€Chainã€Flowï¼‰ä»¥åŠæ–°çš„ DSL æ„å‘³ç€éœ€è¦å­¦ä¹ æ–°çš„æ¦‚å¿µå’Œç¼–å†™æ›´å¤šä»£ç ã€‚æœ€ç»ˆæˆ‘ä»¬å°†èŠ±è´¹æ›´å¤šæ—¶é—´å­¦ä¹ å’Œä¸ DSL ææ–—ã€‚

åœ¨æˆ‘ä»¬ä½¿ç”¨è¿‡çš„æ‰€æœ‰é¡¹ç›®ä¸­ï¼Œä¸€ä¸ªç®€å•çš„ Python å‡½æ•°ä¼¼ä¹æ€»æ˜¯èƒ½å¥æ•ˆã€‚æˆ‘ä»¬è¿˜å‘ç°å¤æ‚çš„æµç¨‹å¯èƒ½è·¨è¶Šå¤šä¸ªæ–‡ä»¶ï¼Œæœ‰æ—¶æœ¬èº«å°±å˜æˆäº†ä¸€ä¸ªæ¨¡å—ã€‚è¿™é‡Œä»€ä¹ˆä¸œè¥¿æ•ˆæœå¾ˆå¥½ï¼ŸPythonã€‚

æˆ‘ä»¬åˆå›åˆ°äº†[Unix å“²å­¦](https://en.wikipedia.org/wiki/Unix_philosophy)ã€‚

å¦‚æœæˆ‘ä»¬çš„å·¥ä½œæµç¨‹æ— æ³•ç”¨æ ‡å‡†çš„ Python ç¼–å†™ï¼Œé‚£ä¹ˆæˆ‘ä»¬åº”è¯¥ç®€åŒ–å’Œé‡ç»„æˆ‘ä»¬çš„å·¥ä½œæµç¨‹ï¼Œè€Œä¸æ˜¯åè¿‡æ¥ã€‚

å¦ä¸€ä¸ªå…³äºé•¿æ—¶é—´è¿è¡Œçš„å·¥ä½œæµç¨‹çš„é‡å¤§æŒ‘æˆ˜æ˜¯ç®¡ç†è¯·æ±‚/å“åº”è¶…æ—¶ã€‚æˆ‘ä»¬éœ€è¦å·¥ä½œæµç¨‹å¼‚æ­¥è§¦å‘ï¼Œç¡®è®¤å¯åŠ¨å¹¶å°†å“åº”è¿”å›ç»™å®¢æˆ·ç«¯ï¼Œç„¶åå…è®¸å®¢æˆ·ç«¯ç¨åè½®è¯¢ç»“æœã€‚å®ç°è¿™ç§ç”¨æˆ·ä½“éªŒéœ€è¦å°†å·¥ä½œæµç¨‹è¿è¡Œåœ¨åå°ä»»åŠ¡ä¸­ï¼Œå¹¶å¯†åˆ‡ç®¡ç†çŠ¶æ€ï¼Œä»¥ä¾¿å®¢æˆ·ç«¯èƒ½å¤Ÿè·å¾—æœ€æ–°çš„æ›´æ–°ã€‚

åŸºäºè¿™äº›åŸå› ï¼Œæˆ‘ä»¬å»ºè®®å°†å·¥ä½œæµç¨‹æ„å»ºä¸ºæ ‡å‡†çš„ Python å‡½æ•°ï¼Œå…¶æä¾›çš„æ§åˆ¶ã€çµæ´»æ€§å’Œå¯é æ€§æ˜¯æ— ä¸ä¼¦æ¯”çš„ã€‚

</Tip>